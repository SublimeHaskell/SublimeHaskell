%YAML 1.2
---
# Enhanced SublimeHaskell syntax highlighting.
#
# Based on the SublimeText Haskell syntax highlighting spec.
# Ref: http://www.sublimetext.com/docs/3/syntax.html

name: Haskell
file_extensions: [hs, hsc]
scope: source.haskell

variables:
  # GHC pragmas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas
  ghc_pragmas: '(LANGUAGE|OPTIONS_GHC|IN(CLUDE|LINE|COHERENT|LINABLE)|WARNING|DEPRECATED|MINIMAL|UNPACK|NOUNPACK|SOURCE|OVERLAP(PING|PABLE|S)|NOINLINE|CONLIKE|LINE|RULES|SPECIALI[SZ]E)'
  # Haskell keywords, i.e., invalid variable names
  haskell_kw: '\b(deriving|where|data|type|case|of|let|in|newtype|import|module|if|then|else)\b'
  tycon_id: '(?<!'')\b[A-Z][\w'']*'
  var_id: '(?!{{haskell_kw}})\b[a-z_][\w'']*'
  unicode_misc: '[\u2605\u2606]'
  oper_id: '([!"#$%&''()*+,\-.\/\[\]:<=>@?\{\}^_\|~\\]|{{unicode_misc}})+'
  unit_oper: '\(\)'
  possible_tycon_arg: '(\s+({{tycon_id}}|{{var_id}}))'
  eol: '$\n?'

contexts:
  main:
    #####
    ##### Note: Pattern matches are listed in priority order (more specific come before more general.)
    #####

    ## A backtick-quoted operator application (i.e., 2 arg function), e.g., 4 `elem` [1..10]
    - match: "(`)[a-zA-Z_']*?(`)"
      scope: keyword.operator.function.infix.haskell
      captures:
        1: punctuation.definition.entity.haskell
        2: punctuation.definition.entity.haskell

    ## Double-dash can also be a prefix for an operator and not a comment leader.
    - match: --(?!\s|-+)({{oper_id}}.+)\b
      scope: keyword.operator.function.infix.haskell
    ## Block and double-dash comments (needs to appear after double-dash for an operator prefix)
    - include: comments

    ## Unit '()'
    - match: '{{unit_oper}}'
      scope: constant.language.unit.haskell entity.name.constructor.haskell

    ## Empty list
    - match: '\[\]'
      scope: constant.language.empty-list.haskell

    - include: module_decl

    ## (Type)class definition
    - match: \b(class)\b
      captures:
        1: keyword.other.haskell
      push:
        - meta_scope: meta.declaration.class.haskell
        - match: \b(where)\b
          captures:
            1: keyword.other.haskell
          pop: true
        - match: \b(Mon(ad|oid)|Functor|Applicative|(Folda|Traversa)ble|Eq|Ord|Read|Show|Num|(Frac|Ra)tional|Enum|Bounded|Real(Frac|Float)?|Integral|Floating)\b
          scope: support.class.prelude.haskell
        - match: "[A-Z][A-Za-z_']*"
          scope: entity.other.inherited-class.haskell
        - match: '\b[a-z][a-zA-Z0-9_'']*\b'
          scope: variable.other.generic-type.haskell
        - include: comments

    ## Class instance definition
    - match: \b(instance)\b
      captures:
        1: keyword.other.haskell
      push:
        - meta_scope: meta.declaration.instance.haskell
        - match: \b(where)\b|$
          captures:
            1: keyword.other.haskell
          pop: true
        - include: type_signature

    ## import statement
    - match: \b(import)\b
      captures:
        1: keyword.other.haskell
      push:
        - meta_scope: meta.import.haskell
        - match: ($|;)
          pop: true
        - match: (qualified|as|hiding)
          scope: keyword.other.haskell
        - include: module_name
        - include: module_exports
        - include: comments

    ## newtype definition
    - match: ^\s*(newtype)\s+
      captures:
        1: keyword.declaration.data.haskell
      push:
        - meta_scope: meta.newtype_declaration.haskell
        - match: (=)
          pop: true

    - include: data_decl
    - include: solitary_deriving

    ## Keywords:
    - match: \b(where|data|type|case|of|let|in|default)\b
      scope: keyword.other.haskell
    - match: '\binfix[lr]?\b'
      scope: keyword.operator.haskell
    - match: \b(do|if|then|else)\b
      scope: keyword.control.haskell
    - match: \bundefined\b
      scope: support.function.prelude.haskell invalid.haskell

    ## Numbers
    ### Single precision constants:
    - match: '\b([0-9]+\.[0-9]+([eE][+-]?[0-9]+)?|[0-9]+[eE][+-]?[0-9]+)\b'
      comment: Floats are always decimal
      scope: constant.numeric.float.haskell
    ### Double precision constants:
    - match: '\b([0-9]+|0([xX][0-9a-fA-F]+|[oO][0-7]+))\b'
      scope: constant.numeric.haskell
    - match: ^\s*(#)\s*\w+
      comment: In addition to Haskell's "native" syntax, GHC permits the C preprocessor to be run on a source file.
      scope: meta.preprocessor.c
      captures:
        1: punctuation.definition.preprocessor.c

    ## String constant
    - match: '"'
      scope: punctuation.definition.string.begin.haskell
      push:
        - meta_scope: string.quoted.double.haskell
        - match: $|"
          scope: punctuation.definition.string.end.haskell
          pop: true
        - match: '\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\"''\&])'
          scope: constant.character.escape.haskell
        - match: '\\o[0-7]+|\\x[0-9A-Fa-f]+|\\[0-9]+'
          scope: constant.character.escape.octal.haskell
        - match: '\^[A-Z@\[\]\\\^_]'
          scope: constant.character.escape.control.haskell

    ## Template Haskell splices
    ### Splices in AST quotes
    - match: '\[(?:|e|d|t|p)\|'
      scope: keyword.other.quasibracket.haskell
      push:
        - meta_scope: meta.other.quasiquote.haskell
        - match: '(.*)(\|\])'
          captures:
            1: string.quasiquoted.haskell
            2: keyword.other.quasibracket.haskell
          pop: true
        - match: \$\(
          scope: keyword.other.splice.haskell
        - match: \$
          scope: string.quasiquoted.haskell
        - match: "[^$]*"
          scope: string.quasiquoted.haskell

    ### Splice start/beginning
    - match: \$\(
      scope: keyword.other.splice.haskell

    ### Splice
    - match: '\[[a-zA-Z0-9_'']*\|'
      scope: keyword.other.quasibracket.haskell
      push:
        - meta_scope: meta.other.quasiquote.haskell
        - match: '(.*)(\|\])'
          captures:
            1: string.quasiquoted.haskell
            2: keyword.other.quasibracket.haskell
          pop: true
        - match: .*
          scope: string.quasiquoted.haskell

    ## Individual characters
    ##### Note: (?x) indicates a freeform regexp. Non-escaped whitespace will be consumed and elided.
    - match: |-
        (?x)
        (')
        (?:
          [\ -\[\]-~]                             # Basic Char
          | (\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE
            |DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS
            |US|SP|DEL|[abfnrtv\\\"'\&]))       # Escapes
          | (\\o[0-7]+)                             # Octal Escapes
          | (\\x[0-9A-Fa-f]+)                       # Hexadecimal Escapes
          | (\^[A-Z@\[\]\\\^_])                     # Control Chars
        )
        (')
      scope: string.quoted.single.haskell
      captures:
        1: punctuation.definition.string.begin.haskell
        2: constant.character.escape.haskell
        3: constant.character.escape.octal.haskell
        4: constant.character.escape.hexadecimal.haskell
        5: constant.character.escape.control.haskell
        6: punctuation.definition.string.end.haskell

    ## Function signature
    - match: '^\s*(,\s*)?(({{var_id}})|\({{oper_id}}+\))\s*(::|∷)'
      captures:
        2: entity.name.function.haskell
        4: keyword.other.double-colon.haskell
      push:
        - meta_scope: meta.function.type-declaration.haskell
        # Termination condition
        - match: |-
            (?x)
                ^(data|newtype|type|class|deriving)\s    # When a top level declaration starts
              | ^[^=]*(=)[\sa-zA-Z0-9_\(]                # A function declaration
          captures:
            1: keyword.other.haskell
            2: keyword.operator.haskell
          pop: true
        - include: comments
        - include: type_signature

    ## Type constructors (anything starting with an uppercase letter)
    - match: '{{tycon_id}}(?!{{possible_tycon_arg}}*\s*\|)'
      scope: constant.other.haskell
    - include: infix_op

    ## Operators
    - match: '{{oper_id}}'
      scope: keyword.operator.haskell

    ## And commas. Some color schemes have different colors for commas. Huh.
    - match: ","
      scope: punctuation.separator.comma.haskell

  block_comment:
    ## Pragma
    - match: '\{-#'
      scope: punctuation.pragma.haskell comment.pragma.haskell
      push:
        - meta_scope: meta.preprocessor.haskell
        - match: '#-\}'
          scope: punctuation.pragma.haskell comment.pragma.haskell
          pop: true
        - match: '\b{{ghc_pragmas}}\b'
          scope: keyword.preprocessor.haskell
        - match: '\b([A-Z][a-z]*)+\b'
          scope: keyword.other.preprocessor.haskell pragma.support.language.haskell
        - match: '(-\w+)'
          scope: keyword.other.preprocessor.haskell pragma.support.flag.haskell

    ## Normal block comment
    - match: '\{-(?!#)'
      scope: punctuation.comment.haskell
      push:
        - meta_scope: comment.block.haskell
        - match: '\{-'
          push:
            - match: '-\}'
              pop: true
            - include: block_comment
        - include: block_comment
        - match: '-\}'
          scope: punctuation.definition.comment.end.haskell
          pop: true

  comments:
    - match: '--'
      scope: punctuation.definition.comment.haskell
      push:
        - meta_scope: comment.line.double-dash.haskell
        - match: '{{eol}}'
          pop: true
    - include: block_comment

  infix_op:
    - match: '(\({{oper_id}})'
      scope: entity.name.function.infix.haskell

  module_decl:
    ## module header
    - match: \b(module)\b
      captures:
        1: keyword.module.haskell
      push:
        - meta_scope: meta.declaration.module.haskell
        - match: (where)
          captures:
            1: keyword.module.haskell
          pop: true
        - include: module_name
        - include: module_exports
        - match: "[a-z]+"
          scope: invalid

  module_exports:
    - match: \(
      scope: storage.module.haskell
      push:
        - meta_scope: meta.declaration.exports.haskell
        - match: \)
          pop: true
          scope: storage.module.haskell
        - match: '\b[a-z][a-zA-Z_''0-9]*'
          scope: entity.name.function.haskell
        - match: '\b[A-Z][A-Za-z_''0-9]*'
          scope: storage.type.haskell
        - match: ","
          scope: punctuation.separator.comma.haskell
        - include: infix_op
        - match: \(.*?\)
          comment: So named because I don't know what to call this.
          scope: meta.other.unknown.haskell
        - include: comments

  module_name:
    - match: "[A-Z][A-Za-z._']*"
      scope: support.other.module.haskell storage.module.haskell

  type_signature:
    - include: comments
    - match: "(->|→)"
      scope: keyword.other.arrow.haskell
    - match: "(=>|⇒)"
      scope: keyword.other.big-arrow.haskell
    - match: '{{var_id}}'
      scope: variable.other.generic-type.haskell
    - match: '{{tycon_id}}'
      scope: storage.type.haskell
    - match: '{{unit_oper}}'
      scope: entity.name.constructor.haskell support.constant.unit.haskell

  data_decl:
    ## data type definition
    - match: '^\s*(data)\s+({{tycon_id}})(\s+({{var_id}}))*\s*'
      captures:
        1: keyword.declaration.data.haskell
        2: constant.other.haskell entity.name.class.haskell
        3: variable.generic.haskell
      push:
        - meta_scope: meta.data_declaration.haskell
        - match: (=)\s*({{tycon_id}})
          captures:
            1: keyword.operator.haskell
            2: entity.name.constructor.haskell
        ## Push context for ordinary type constructors, terminate the context when we hit the end of the line
        - match: '{{eol}}'
          pop: true
        - match: (\bderiving\b)
          captures:
            1: keyword.other.haskell
          push:
            - meta_scope: meta.data_deriving.haskell
            - include: deriving_clause
        - include: tycon_args
        - include: comments

    ## For data constructors that continue on following line:
    ##
    ## | Foo ...
    ##
    ## Foo ... | ...
    ##
    ## | Foo ... |
    - match: '^\s+((\|)\s*)?({{tycon_id}})(?={{possible_tycon_arg}}*(\s*(\|))?)'
      captures:
        2: keyword.operator.haskell
        3: entity.name.function entity.name.constructor.haskell
        5: keyword.operator.haskell
      push:
        - match: '{{eol}}'
          pop: true
        - include: tycon_args
        - include: comments
    - include: comments

  solitary_deriving:
    ## A 'deriving' clause on its own line.
    - match: '^\s+(deriving)'
      captures:
        1: keyword.other.haskell
      push:
        - meta_scope: meta.data_deriving.haskell
        - include: deriving_clause
    - include: comments

  tycon_args:
    - match: '({{tycon_id}})'
      captures:
        1: storage.type.haskell support.type.haskell
    - match: '({{var_id}})'
      captures:
        1: variable.generic.haskell
    - match: '(\|)\s*({{tycon_id}})?'
      captures:
        1: keyword.operator.haskell
        2: entity.name.function entity.name.constructor.haskell
    - include: comments

  deriving_clause:
    # 'deriving' clauses: a single type constructor or a parenthesized list of type constructors.
    - match: '{{tycon_id}}'
      scope: storage.type.haskell support.type.haskell
      pop: true
    - match: '\('
      scope: keyword.operator.haskell
      push:
        - match: '(\))'
          captures:
            1: keyword.operator.haskell
          pop: true
        - match: '{{tycon_id}}'
          scope: storage.type.haskell support.type.haskell
        - match: ','
          scope: punctuation.separator.comma.haskell
        - include: comments
      pop: true
    - include: comments
